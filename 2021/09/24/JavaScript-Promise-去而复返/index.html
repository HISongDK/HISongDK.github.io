<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="原文：JavaScript Promises: an introduction作者：Jake Archibald时间：Dec 16, 2013翻译：Amio转自：司徒 女士们先生们，请准备好迎接 Web 开发历史上一个重大时刻…… [鼓声响起]  JavaScript 有了原生的 Promise!  [漫天的烟花绽放，人群沸腾了]">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript Promise: 去而复返">
<meta property="og:url" content="http://example.com/2021/09/24/JavaScript-Promise-%E5%8E%BB%E8%80%8C%E5%A4%8D%E8%BF%94/index.html">
<meta property="og:site_name" content="某人写字的地方">
<meta property="og:description" content="原文：JavaScript Promises: an introduction作者：Jake Archibald时间：Dec 16, 2013翻译：Amio转自：司徒 女士们先生们，请准备好迎接 Web 开发历史上一个重大时刻…… [鼓声响起]  JavaScript 有了原生的 Promise!  [漫天的烟花绽放，人群沸腾了]">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/09/images/promise-flow.svg">
<meta property="og:image" content="https://link/">
<meta property="og:image" content="https://link/">
<meta property="og:image" content="https://link/">
<meta property="article:published_time" content="2021-09-24T06:38:13.000Z">
<meta property="article:modified_time" content="2021-11-05T15:56:23.980Z">
<meta property="article:author" content="Somebody">
<meta property="article:tag" content="随敲">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/09/images/promise-flow.svg">

<link rel="canonical" href="http://example.com/2021/09/24/JavaScript-Promise-%E5%8E%BB%E8%80%8C%E5%A4%8D%E8%BF%94/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript Promise: 去而复返 | 某人写字的地方</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">某人写字的地方</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-sitemap fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/09/24/JavaScript-Promise-%E5%8E%BB%E8%80%8C%E5%A4%8D%E8%BF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Somebody">
      <meta itemprop="description" content="My vegetable has exploded!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="某人写字的地方">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript Promise: 去而复返
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-24 14:38:13" itemprop="dateCreated datePublished" datetime="2021-09-24T14:38:13+08:00">2021-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 23:56:23" itemprop="dateModified" datetime="2021-11-05T23:56:23+08:00">2021-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E6%95%B2/" itemprop="url" rel="index"><span itemprop="name">随敲</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>原文：<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/">JavaScript Promises: an introduction</a><br>作者：<a target="_blank" rel="noopener" href="http://www.html5rocks.com/profiles/#jakearchibald">Jake Archibald</a><br>时间：Dec 16, 2013<br>翻译：<a href="./#%E6%9C%AA%E7%9F%A5%E4%BA%86%E5%B7%B2%E7%BB%8F%E6%98%AF">Amio</a><br>转自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rubylouvre/p/3495286.html">司徒</a></p>
<p>女士们先生们，请准备好迎接 Web 开发历史上一个重大时刻……</p>
<p>[鼓声响起]</p>
<blockquote>
<p>JavaScript 有了原生的 Promise!</p>
</blockquote>
<p>[漫天的烟花绽放，人群沸腾了]</p>
<a id="more"></a>

<ul>
<li><a href="#%E4%BB%96%E4%BB%AC%E9%83%BD%E5%9C%A8%E6%BF%80%E5%8A%A8%E4%BB%80%E4%B9%88">他们都在激动什么？</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E4%B8%8D%E6%98%AF%E4%B8%87%E9%87%91%E6%B2%B9">事件不是万金油</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">相关术语</a></li>
<li><a href="#javascript-%E6%9C%89%E4%BA%86-promise">JavaScript 有了 Promise</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E5%92%8C-polyfill">浏览器支持和 Polyfill</a></li>
<li><a href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7">与其他库的兼容性</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%8F%98%E5%BE%97%E6%9B%B4%E7%AE%80%E5%8D%95%E4%BA%86">复杂的异步代码变得更简单了</a></li>
<li><a href="#%E5%B0%86-promise-%E7%94%A8%E4%BA%8E-xmlhttprequest">将 Promise 用于 XMLHttpRequest</a></li>
<li><a href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">链式调用</a><ul>
<li><a href="#%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86">值的处理</a></li>
<li><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C">队列的异步操作</a></li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">错误处理</a><ul>
<li><a href="#javascript-%E5%BC%82%E5%B8%B8%E5%92%8C-promise">JavaScript 异常和 Promise</a></li>
<li><a href="#%E5%AE%9E%E8%B7%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">实践错误处理</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E4%B8%B2%E8%A1%8C%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%85%BC%E5%BE%97">并行和串行————鱼与熊掌兼得</a><ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%BA%8F%E5%88%97">创建序列</a></li>
</ul>
</li>
<li><a href="#%E9%99%84%E8%B5%A0%E7%AB%A0%E8%8A%82promise-%E5%92%8C-generator">附赠章节：Promise 和 Generator</a></li>
<li><a href="#promise-api-%E5%8F%82%E8%80%83">Promise API 参考</a><ul>
<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a><ul>
<li><a href="#promisecastpromise">Promise.cast(promise)</a></li>
<li><a href="#promisecastobj">Promise.cast(obj)</a></li>
<li><a href="#promiseresolvethenable">Promise.resolve(thenable)</a></li>
<li><a href="#promiseresolveobj">Promise.resolve(obj)</a></li>
<li><a href="#promiserejectobj">Promise.reject(obj)</a></li>
<li><a href="#promiseallobj">Promise.all(obj)</a></li>
<li><a href="#promiseracearray">Promise.race(array)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这时候你大概是这三种人之一：</p>
<ul>
<li>你的身边拥挤着欢呼的人群，但是你却不在其中，甚至你还不大清楚”Promise”是什么。你耸耸肩，烟花的碎屑在你身边落下。这样的话，不要担心，我也是花了多年的时间才明白 Promise 的意义，你可以从<a href="#%E4%BB%96%E4%BB%AC%E9%83%BD%E5%9C%A8%E6%BF%80%E5%8A%A8%E4%BB%80%E4%B9%88%EF%BC%9F">入门简介：他们都在激动什么？</a>开始看起。</li>
<li>你一挥拳！太赞了对么！你已经用过一些 Promise 的库，但是所有这些第三方实现在 API 上都略有差异，JavaScript 官方的 API 会是什么样子？看<a href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">这里：Promise 术语</a>！</li>
<li>你早就知道了，看着那些欢呼雀跃的新人的你的嘴角泛起一丝不屑的微笑。你可以安静享受一会优越感，然后直接去看<a href="#promise-api-%E5%8F%82%E8%80%83">API 参考</a>吧。</li>
</ul>
<h2 id="他们都在激动什么？"><a href="#他们都在激动什么？" class="headerlink" title="他们都在激动什么？"></a>他们都在激动什么？</h2><p>JavaScript 是单线程的，这意味着任何两句代码都不能同时运行，他们得一个接一个来。在浏览器中，JavaScript 和其它任务共享一个线程，不同的线程略有差异，但大体上这些和 JavaScript 共享线程的任务包括重绘、更新样式、用户交互等，所有这些任务操作都会阻塞其他操作。</p>
<p>作为人类，你是多线程的。你可以多个手指同时敲键盘，也可以一边开车一边电话。唯一的全局阻塞函数就是打喷嚏，打喷嚏期间所有其他事务都会暂停。很烦人对么？尤其当你在开着车打着电话的时候。我们都不喜欢这样打喷嚏的代码。</p>
<p>你应该会用事件 + 回调的办法来处理这类情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.img-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img1.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// woo yey image loaded</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">img1.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// argh everything&#x27;s broken</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就不打喷嚏了。我们添加几个监听函数，请求图片，然后 JavaScript 就停止运行了，直到触发某个监听函数。</p>
<p>上面的例子中唯一的问题是，事件有可能在我们绑定监听器之前就已经发生了，所以我们先要检查图片的<code>complete</code>属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;img-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loaded</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// woo yey image loaded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (img1.complete) &#123;</span><br><span class="line">  loaded()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  img1.addEventListener(<span class="string">&#x27;load&#x27;</span>, loaded)</span><br><span class="line">&#125;</span><br><span class="line">img1.addEventListener(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// argh everything&#x27;s broken</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样还不够，如果在监听函数之前图片加载发生错误，我们的监听函数还是白费，不幸的是 DOM 也没有为这个需求提供解决办法。而且，这还只是处理一张图片的情况，如果有一堆图片要处理就更麻烦了。</p>
<h2 id="事件不是万金油"><a href="#事件不是万金油" class="headerlink" title="事件不是万金油"></a>事件不是万金油</h2><p>事件机制最适合处理在同一个对象上反复发生的事情————keyup、touchstart 等等。你不需要考虑当绑定事件之前发生的事情，当碰到异步请求成功/失败的时候，你想要的通常是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">img1</span><br><span class="line">  .callThisIfLoadedOrWhenLoaded(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// loaded</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .orIfFailedCallThis(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// failed</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// and ...</span></span><br><span class="line">whenAllTheseHaveLoaded([img1, img2])</span><br><span class="line">  .callThis(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// all load</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .orIfSomeFailedCallThis(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// one or more failed</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这就是 Promise。如果 HTML 图片元素有一个<code>ready()</code>方法的话，我们就可以这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">img1.ready().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// loaded</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// failed</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// and ...</span></span><br><span class="line"><span class="built_in">Promise</span>.all([img1.ready(), img2.ready()]).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// all loaded</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// one or more failed</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>基本上 Promise 还是有点像事件回调的，除了：</p>
<ul>
<li>一个 Promise 只能成功或失败一次，并且状态无法改变（不能从成功变为失败，反之亦然）</li>
<li>如果一个 Promise 成功或者失败之后，你为其添加针对成功/失败的回调，则相应的回调函数会立即执行</li>
</ul>
<p>这些特性非常适合处理异步操作的成功/失败情景，你无需担心事件发生的时间点，而只需对其做出响应。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p><a target="_blank" rel="noopener" href="https://twitter.com/domenic">Domenico Denicoia</a>审阅了本文初稿，给我在术语方面打了个”F”,关了禁闭并且责令我打印 <a target="_blank" rel="noopener" href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and Fates</a>一百遍，还写了一封家长信给我父母。即便如此，我还是对术语有些迷糊，不过基本上应该是这样：</p>
<p>一个 Promise 的状态可以是：</p>
<p><strong>确认（fulfilled）</strong> - 成功了<br><strong>否定（rejected）</strong> - 失败了<br><strong>等待（pending）</strong> - 还没有确认或者否定<br><strong>结束（settled）</strong> - 已经确认或者否定了</p>
<p>规范里还使用”thenable”来描述一个对象是否是”类 Promise”（拥有名为”then”的方法）的。这个术语是我想起来前英格兰足球经理<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Terry_Venables">Terry Venables</a>,所以我尽量少使用它。</p>
<h2 id="JavaScript-有了-Promise"><a href="#JavaScript-有了-Promise" class="headerlink" title="JavaScript 有了 Promise"></a>JavaScript 有了 Promise</h2><p>其实已经有一些第三方库实现了 Promise：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/kriskowal/q">Q</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/cujojs/when">when</a></li>
<li><a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">WinJS</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tildeio/rsvp.js">RSVP.js</a></li>
</ul>
<p>上面这些库和 JavaScript 原生 Promise 都遵守一个通用的、标准化的规范：<br><a target="_blank" rel="noopener" href="https://github.com/promises-aplus/promises-spec">Promise/A+</a>,jQuery 有一个类似的方法叫 <a target="_blank" rel="noopener" href="http://api.jquery.com/category/deferred-object/">Deferreds</a>,但不兼容 Promise/A+规范，于是会<a target="_blank" rel="noopener" href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/">有一点小问题</a>，使用需谨慎。jQuery 还有一个 <a target="_blank" rel="noopener" href="http://api.jquery.com/Types/#Promise">Promise 类型</a>,但只是 Defereds 的缩减版，所以也会有同样的问题。</p>
<p>尽管 Promise 的各路实现遵循同一规范，它们的 API 还是各不相同。JavaScript Promise 的 API 比较接近 RSVP.js，如下创建 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// do a thing,possibly async,then...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="comment">/* everything turned out fine */</span>)&#123;</span><br><span class="line">    resolve(<span class="string">&quot;Stuff worked!&quot;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(<span class="string">&quot;It broken&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promise 的构造器接受一个函数作为参数，它会传递给这个回调函数两个变量 resolve 和 reject。在回调函数中做一些异步操作，成功之后调用 resolve，否则调用 reject。</p>
<p>调用 reject 的时候传递给它一个 Error 对象只是个惯例并非必需，这和经典的 JavaScript 中的 throw 一样。传递 Error 对象的好处是它包含了调用堆栈，在调试的时候会用点好处。</p>
<p>现在来看看如何使用 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result) <span class="comment">// &quot;Stuff worked!&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err) <span class="comment">//Error: &quot;It broke&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>then</code>接受两个参数，成功的时候调用一个，失败的时候调用另一个，两个都是可选的，所以你可以只处理成功的情况或者失败的情况。<br>JavaScript Promise 最初以 “Futures” 的名称归为 DOM 规范，后来改名为”Promise”,最终纳入 JavaScript 规范。将其加入 JavaScript 而非 DOM 的好处是方便非浏览器环境使用，如 Node.js（他们会不会在核心 API 中使用就是另外一回事了）。</p>
<h2 id="浏览器支持和-Polyfill"><a href="#浏览器支持和-Polyfill" class="headerlink" title="浏览器支持和 Polyfill"></a>浏览器支持和 Polyfill</h2><p>目前的浏览器已经（部分）实现了 Promise。</p>
<p>用 Chrome 的话，就像个 Chroman 一样装上 Canary 版，默认启用了 Promise 支持。如果是 Firefox 的拥趸，安装最新的 nightly build 也一样。</p>
<p>不过这两个浏览器的实现都还不够完整彻底，你可以在 bugzilla 上跟踪 Firefox 的最新进展或者到 Chromium Dashboard 查看 Chrome 的实现情况。</p>
<p>要在这两个浏览器上达到兼容标准 Promise，或者在其他浏览器以及 Node.js 中使用 Promise，可以看看这个 <a target="_blank" rel="noopener" href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md">polyfill</a>（gzip 之后 2k）</p>
<h2 id="与其他库的兼容性"><a href="#与其他库的兼容性" class="headerlink" title="与其他库的兼容性"></a>与其他库的兼容性</h2><p>JavaScript Promise 的 API 会把任何包含有<code>then</code>方法的对象当作“类 Promise”（或者用术语来说就是 thenable。叹气）的对象，这些对象经过<code>Promise.cast()</code>处理之后就和原生的 JavaScript Promise 没有任何区别了。所以若果你使用的库返回一个 Q Promise，那没问题，无缝融入新的 JavaScript Promise。</p>
<p>尽管，如前所述，jQuery 的 Deferred 对象有点…没什么用，不过幸好可以转换成标准 Promise，你最好一拿到对象就马上加以转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.cast($.ajax(<span class="string">&#x27;/whatever.json&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这里 jQuery 的<code>$.ajax</code>返回一个 Deferred 对象，含有<code>then</code>方法，因此<code>Promise.cast</code>可以将其转换为 JavaScript Promise。不过有时候 Deferred 对象会给它的回调函数传递多个参数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqDeferred = $.ajax(<span class="string">&#x27;/whatever.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">jqDeferred.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">response, statusText, xhrObj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">xhrObj, textStatus, err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>除了第一个参数，其他都会被 JavaScript 忽略掉：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jsPromise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">xhrObj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>……还好这通常就是你想要的了，至少你能够用这个方法实现想要的，另外还要注意，jQuery 也没有遵循给否定回调函数传递 Error 的惯例。</p>
<h2 id="复杂的异步代码变得更简单了"><a href="#复杂的异步代码变得更简单了" class="headerlink" title="复杂的异步代码变得更简单了"></a>复杂的异步代码变得更简单了</h2><p>OK，现在我们来写点实际代码。假设我们想要：</p>
<ol>
<li>显示一个加载指示图标</li>
<li>加载一篇小说的 JSON，包含小说名和每一章内容的 URL</li>
<li>在页面中填上小说名</li>
<li>加载所有章节正文</li>
<li>在页面中添加章节正文</li>
<li>停止加载指示</li>
</ol>
<p>…这个过程中如果发生什么错误了要通知用户，并且把加载指示停掉，不然他就会不停转下去，令人眼晕，或者搞坏界面什么的。</p>
<p>当然了，你不会用 JavaScript 去这么繁琐的显示一篇文章，直接输出 HTML 要快得多，不过这个流程是非常典型的 API 请求模式：获取多个数据，当他们全部完成之后在做一些事情。</p>
<p>首先搞定从网络加载数据的步骤：</p>
<h2 id="将-Promise-用于-XMLHttpRequest"><a href="#将-Promise-用于-XMLHttpRequest" class="headerlink" title="将 Promise 用于 XMLHttpRequest"></a>将 Promise 用于 XMLHttpRequest</h2><p>只要能保持向后兼容，现有的 API 都会更新以支持 Promise，XMLHttpRequest 是重点考虑对象之一。不过现在我们先来写个 GET 请求：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Return a new Promise.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Do the usual XHR Stuff</span></span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    req.open(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// This is called even on 404 etc 这里甚至会被404或其他状态调用</span></span><br><span class="line">      <span class="comment">// so check the status code</span></span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// Resolve the promise with the response text</span></span><br><span class="line">        resolve(req.response)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise reject the promise with the status text</span></span><br><span class="line">        <span class="comment">// which will hopefully be a meaningful error message</span></span><br><span class="line">        reject(req.statusText)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="built_in">Error</span>(<span class="string">&#x27;Network error&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the request</span></span><br><span class="line">    req.send()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successful&#x27;</span>, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;Failed&#x27;</span>, error)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/story.json">点击这里查看代码运行页面</a>,打开控制台查看输出结果。现在我们可以直接发起 HTTP 请求，而不用手敲 XMLHttpRequest，这样感觉好多了，能少看一次这个狂驼峰命名的 XMLHttpRequest 我就多快乐一点。</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>“then”的故事还没完，你可以把这些”then”串联起来修改结果或者添加进行更多的异步操作。</p>
<h3 id="值的处理"><a href="#值的处理" class="headerlink" title="值的处理"></a>值的处理</h3><p>你可以对结果做些修改然后返回一个新值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> val + <span class="number">2</span></span><br><span class="line">    <span class="comment">// then 函数第一个回调函数参数的返回值作为下一个 then 函数第一个回调函数参数的参数</span></span><br><span class="line">    <span class="comment">// 我才知道</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// 3</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>回到前面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Success!&#x27;</span>, response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>收到的响应是一个纯文本的 JSON，我们可以修改 get 函数，设置 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#responseType">responseType</a>要求服务器以 jSON 格式提供响应，不过还是用 Promise 的方式来搞定吧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Yey JSON!&#x27;</span>, response)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>既然<code>JSON.parse</code>只接收一个参数，并返回转换后的结果，我们还可以再精简一点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="built_in">JSON</span>.parse) <span class="comment">// 秀儿</span></span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Yey JSON!&#x27;</span>, response)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/story.json">点击这里查看代码运行页面</a>,打开控制台查看输出结果。事实上，我们可以把<code>getJSON</code>函数写的超级简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(url).then(<span class="built_in">JSON</span>.parse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getJson</code>会返回一个获取 JSON 并加一解析的 Promise。</p>
<h3 id="队列的异步操作"><a href="#队列的异步操作" class="headerlink" title="队列的异步操作"></a>队列的异步操作</h3><p>你也可以把 <code>then</code> 串联起来依次执行异步操作。</p>
<p>当你从 <code>then</code> 的回调函数返回的时候，这里有点小魔法。<!--不是都说禁止在麻瓜面前使用魔法的么-->如果你返回一个值，他就会被传给下一个 <code>then</code> 的回调；而如果你返回一个’类 Promise’的对象，则下一个 <code>then</code> 就会等待这个 Promise 明确结束（成功/失败）才会执行。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">story</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(story.chaterUrls[<span class="number">0</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter1</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Got chapter 1!&#x27;</span>, chapter1)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这里我们发起一个对 story.json 的异步请求，返回给我们更多的 URL，然后我们会请求其中的第一个。Promise 开始首次显现出相较事件回调的优越性了。你甚至可以写一个抓取章节内容的独立函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storyPromise</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getChapter</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  storyPromise = storyPromise || getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> storyPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">story</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(story.chaterUrls[i])</span><br><span class="line">    <span class="comment">// 哦豁完蛋 tabnine 都知道我要打什么，我反而没看懂</span></span><br><span class="line">    <span class="comment">// 人工智能显得本人制杖啊</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and using is is simple</span></span><br><span class="line">getChapter(<span class="number">0</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chapter)</span><br><span class="line">    <span class="keyword">return</span> getChapter(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chapter)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>我们一开始并不加载 story.json,直到第一次 getChapter,而以后每次 getChapter 的时候都可以重用已完成的 story Promise,所以 story.json 只需要请求一次。Promise 好棒！</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>前面已经看到，”then”接受两个参数，一个处理成功，一个处理失败（或者说确认和否定，按 Promise 术语）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successful!&#x27;</span>, response)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Failed!&#x27;</span>, error)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>你还可以使用 <code>catch</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Successful!&#x27;</span>, response)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Failed!&#x27;</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>catch</code>并无任何特别之处，只是 <code>then(undefined, func)</code> 的语法糖衣，更直观一点而已。注意上面两段代码的行为不尽相同，后者相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;story.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Successful!&#x27;</span>, response)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="literal">undefined</span>, <span class="keyword">function</span> (error) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">console</span>.log(<span class="string">&#x27;Failed!&#x27;</span>, error)</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>差异不大，但意义非凡。</strong>Promise 被否定之后会跳转到之后第一个配置了否定回调的<code>then</code>(或 <code>catch</code> ，一样的)。对于 <code>then(func1,func2)</code> 来说，必会调用 func1 或 func2 之一，但绝不会两个都调用。而 <code>then(func1).catch(func2)</code> 这样，如果 func1 返回否定的话 func2 也会被调用，因为他们是链式调用中独立的两个步骤。看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">asyncThing1()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncThing2()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncThing3()</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRecovery1()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> asyncThing4()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> asyncRecovery2()</span><br><span class="line">    &#125;,</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Don&#x27;t worry about it&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ALL done!&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这段流程非常像 JavaScript 的 try/catch 组合，<code>try</code> 代码块发生的错误会径直跳转到 <code>catch</code> 代码块。这是上面那段代码的流程图（我最爱流程图了）：</p>
<p><img src="../../images/promise-flow.svg" alt="Promise Flow"></p>
<p>绿线是确认的 Promises 流程，红线是否定的。</p>
<h3 id="JavaScript-异常和-Promise"><a href="#JavaScript-异常和-Promise" class="headerlink" title="JavaScript 异常和 Promise"></a>JavaScript 异常和 Promise</h3><p>Promise 的否定回调可以由 <code>Promise.reject()</code> 触发，也可以由构造器回调中抛出的错误触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// JSON.parse throws an error if you feed it some invalid JSON,so this implicitly rejects:</span></span><br><span class="line">  resolve(<span class="built_in">JSON</span>.parse(<span class="string">&quot;This ain&#x27;t JSON&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">jsonPromise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// This never happens:</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;It worded!&#x27;</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Instead, this happens:</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;It failed&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>这意味着你可以把所有 Promise 相关的工作都放在构造函数的回调中进行，这样任何错误都能被捕捉到并且触发 Promise 否定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  .then(<span class="built_in">JSON</span>.parse)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// This never happens,&#x27;/&#x27; is an HTML page,not JSON</span></span><br><span class="line">    <span class="comment">// so JSON.parse throws</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;It worded!&#x27;</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Instead, this happens:</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;It failed!&#x27;</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="实践错误处理"><a href="#实践错误处理" class="headerlink" title="实践错误处理"></a>实践错误处理</h3><p>回到我们的故事和章节，我们用 <code>catch</code> 来捕捉错误并显示给用户：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(story.chapterUrl[<span class="number">0</span>])</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter1</span>) </span>&#123;</span><br><span class="line">    addHtmlToPage(chapter1.html)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    addTextToPage(<span class="string">&#x27;Failed to show chapter&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>如果请求 <code>story.chapterUrl[0</code> 失败（http 500 或者用户掉线什么的）了，他会跳过之后所有针对成功的回调，包括 <code>getJSON</code> 中将响应解析为 JSON 的回调，和这里把第一张内容添加到页面里的回调。JavaScript 的执行会进行入 <code>catch</code> 回调，结果就是前面任何章节请求出错，页面上都会显示：“Failed to show chapter”。</p>
<p>和 JavaScript 的 catch 一样，捕捉到错误之后，接下来的代码会继续执行，按计划把加载指示器给停掉。上面的代码就是下面这段的非阻塞异步版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> story = getJSONSync(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> chapter1 = getJSONSync(<span class="string">&#x27;story.chapterUrl[0]&#x27;</span>)</span><br><span class="line">  <span class="comment">// 你这写个 Sync 具体咋封的，nodejs 好像好多这样的API</span></span><br><span class="line">  addHtmlToPage(chapter1.html)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  addTextToPage(<span class="string">&#x27;Failed to show chapter&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给瞧介 给瞧介 这同步代码要简洁多少 昨天我改获取必应壁纸设置桌面的脚本 把 python 的用 nodejs 实现以下就觉得这请求的有点难受 这种果然要简洁的多啊</span></span><br></pre></td></tr></table></figure>
<p>如果捕捉异常做记录输出，不打算在用户界面对错误进行反馈的话，只要抛出 Error 就行了，这一步可以放在 <code>getJSON</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(url)</span><br><span class="line">    .then(<span class="built_in">JSON</span>.parse)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;getJSON failed for&#x27;</span>, url, err)</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经搞定第一章了，接下来搞定所有的。</p>
<h2 id="并行和串行————鱼与熊掌兼得"><a href="#并行和串行————鱼与熊掌兼得" class="headerlink" title="并行和串行————鱼与熊掌兼得"></a>并行和串行————鱼与熊掌兼得</h2><p>异步的思维方式并不符合直觉<!--很难不赞同-->，如果你觉得起步困难，那就试试先写个同步的方法，就像这个：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> story = getJSONSync(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  addHtmlToPage(story.json)</span><br><span class="line">  story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chapterUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chapter = getJSONSync(chapterUrl)</span><br><span class="line">    addHtmlToPage(chapter.html)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  addTextToPage(<span class="string">&#x27;ALL done&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  addTextToPage(<span class="string">&#x27;Argh,broken:&#x27;</span> + err.message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br></pre></td></tr></table></figure>
<p>它执行起来完全正常！（<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/sync-example.html">查看示例</a>不过它是同步的，在加载内容时会卡住整个浏览器。要让它异步工作的话，我们用 <code>then</code> 把它们一个接一个串起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">story</span>) </span>&#123;</span><br><span class="line">    addHtmlToPage(story.heading)</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> for each url in story.chapterUrls,fetch &amp; display</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// And we&#x27;re all done!</span></span><br><span class="line">    addTextToPage(<span class="string">&#x27;All done&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Catch any error that happened along the way</span></span><br><span class="line">    addTextToPage(<span class="string">&#x27;Argh,broken:&#x27;</span> + err.message)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Always hide the spinner</span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>那么我们如何遍历章节的 URL 并且依次请求？这样是 <strong>不行的</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chapterUrl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Fetch chapter</span></span><br><span class="line">  getJSON(chapterUrl).then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// and add it to the page</span></span><br><span class="line">    addHtmlToPage(chapter.html)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>forEach</code> 没有对异步操作的支持，所以我们的故事章节会按照他们加载完成的顺序显示<!-- 原来如此，你不说我们不知道为啥这样不行 -->，基本上《低俗小说》就是这么写出来的。<!-- 哈哈哈哈什么玩意，小说没看过，电影也忘完了，自然结构顺序更是记不清了，有点无法体会 -->我们不写低俗小说，所以得修正它：</p>
<h3 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h3><p>我们要把章节 URL 数组转换成 Promise 的序列，还是用 <code>then</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start off with a promise that always resolves</span></span><br><span class="line"><span class="keyword">var</span> sequence = <span class="built_in">Promise</span>.resolve()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop through our chapter chapterUrls</span></span><br><span class="line">story.chapterUrls.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chapterUrl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Add these actions to the end of the sequence</span></span><br><span class="line">  sequence = sequence</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getJSON(chapterUrl)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter</span>) </span>&#123;</span><br><span class="line">      addHtmlToPage(chapter.html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这是我们第一次用到 <code>Promise.resolve</code> ,它会依据你传的任何值返回一个 Promise。如果你传给它一个类 Promise 对象（带有 <code>then</code> 方法），它会生成一个带有同样确认/否定回调的 Promise，基本上就是克隆。如果传给它任何别的值，如 <code>Promise.reject(&#39;Hello&#39;)</code> ,它会创建一个以这个值为完成结果的 promise，如果不传任何值，则以 undefined 为完成结果。</p>
<p>还有一个对应的 <code>Promise.reject(val)</code> 会创建以你传入的参数（或 undefined）为否定结果的 Promise。</p>
<p>我们可以使用 <code>array.prototype.reduce</code> 精简一下上面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop through our chapter urls</span></span><br><span class="line">story.chapterUrls.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">sequence,chapterUrl</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// Add these actions to the end of the sequence</span></span><br><span class="line">  <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(chapterUrl)</span><br><span class="line">  &#125;)then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>)</span>&#123;</span><br><span class="line">    addHtmlToPage(chapter.html)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="built_in">Promise</span>.resolve())</span><br></pre></td></tr></table></figure>
<p>她和前面的例子功能一样，但是不需要显式声明 <code>sequence</code> 变量。reduce 回调会以此应用在每个数组元素上，第一轮“sequence”是 <code>Promise.resolves()</code> ,之后的调用“sequence”就是上次函数执行的结果。<code>array.prototype.reduce</code> 非常适合用于把一组值归并处理为一个值，正是我们现在对 Promise 的用法。</p>
<p>汇总下上面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;story.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">story</span>)</span>&#123;</span><br><span class="line">  addHtmlToPage(story.heading)</span><br><span class="line"></span><br><span class="line">  reutrn story.chapterUrls.reduce(<span class="function">(<span class="params">sequence,chapterUrl</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// Once the last chapter&#x27;s promise done ...</span></span><br><span class="line">    <span class="comment">// 对啊 之前还没看懂怎么就保证顺序了，.then要前面返回的Promise执行完才执行</span></span><br><span class="line">    <span class="comment">// 不过其实还是有点没看懂</span></span><br><span class="line">    <span class="keyword">return</span> sequence.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// ...fetch the next chapter</span></span><br><span class="line">      <span class="keyword">return</span> getJSON(chapterUrl)</span><br><span class="line">      <span class="comment">// 又有点明白了，您这个注释讲解是专业的嘿</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// and add it to the page</span></span><br><span class="line">      addTextToPage(chapter.html)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,<span class="built_in">Promise</span>.resolve())</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// And we&#x27;re all done</span></span><br><span class="line">  addTextToPage(<span class="string">&#x27;ALL done&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// Catch any error that happened along the way</span></span><br><span class="line">  addTextToPage(<span class="string">&#x27;Argh,broken:&#x27;</span> + err.message)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// always hide the spinner</span></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/async-example.html">运行实例看这里</a>,前面的同步代码改造成了完全异步的版本。我们还可以更进一步，现在页面的加载效果是这样：</p>
<p><img src="https://link/" alt="图略"></p>
<p>浏览器很擅长同时加载多个文件，我们这种一个接一个下载章节的方法非常不效率。我们希望同时下载所有章节，全部完成后一次搞定，正好就有这么个 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(arrayOfPromises).then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayOfResults</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Promise.all</code> 接受一个 Promise 数组为参数，创建一个当所有 Promise 都完成之后就完成的 Promise，它的完成结果就是一个数组，包含了所有先前传入的那些 Promise 的完成结果，顺序和它们传入的数组顺序一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">story</span>) </span>&#123;</span><br><span class="line">    addHtmlToPage(story.heading)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take an array of promises and wait on them all</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      <span class="comment">// Map our array of chapter urls to an array of chapter json promises</span></span><br><span class="line">      story.chapterUrls.map(getJSON),</span><br><span class="line">      <span class="comment">// 我还能说什么，这代码写的太鬼了</span></span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapters</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Now we have the chapters json in order! Loop through...</span></span><br><span class="line">    chapters.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chapter</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ... and add to the page</span></span><br><span class="line">      addHtmlToPage(chapter.html)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    addTextToPage(<span class="string">&#x27;ALL done&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// catch any error that happened so far</span></span><br><span class="line"></span><br><span class="line">    addTextToPage(<span class="string">&#x27;Argh,broken:&#x27;</span> + err.message)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>根据连接状况，改进的代码会比顺序加载方式提速数秒，甚至代码行数也更少。章节加载完成的顺序不确定，但是它们显示在页面上的顺序准确无误。</p>
<p><img src="https://link/" alt="图略"></p>
<p>然而这样还是有提高空间。当第一章内容加载完毕我们可以立即填进页面，这样用户可以在其他内容尚未加载完成之前就开始阅读；当第三章到达的时候我们不动声色，第二章也到达之后我们再把第二章和第三章内容填入界面，以此类推。</p>
<p>为了达到这样的效果，我们同时请求所有章节的内容，然后创建一个序列将其依次填入界面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">story</span>) </span>&#123;</span><br><span class="line">    addHtmlToPage(story.heading)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map our array of chapter urls to an array of chapter json promises.</span></span><br><span class="line">    <span class="comment">// This makes sure they all download parallel</span></span><br><span class="line">    <span class="keyword">return</span> story.chapterUrls</span><br><span class="line">      .map(getJSON)</span><br><span class="line">      .reduce(<span class="function"><span class="keyword">function</span> (<span class="params">sequence, chapterPromise</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Use reduce to chain the promises together</span></span><br><span class="line">        <span class="comment">// adding content to the page for each chapter</span></span><br><span class="line">        <span class="keyword">return</span> sequence</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// Wait for everything in the sequence so far,then wait for theis chapter to arrive</span></span><br><span class="line">            <span class="keyword">return</span> chapterPromise</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(<span class="function"><span class="keyword">function</span> (<span class="params">chapter</span>) </span>&#123;</span><br><span class="line">            addHtmlToPage(chapter.html)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;, <span class="built_in">Promise</span>.resolve())</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    addTextToPage(<span class="string">&#x27;ALL done&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Catch any error that happend along the way</span></span><br><span class="line">    addTextToPage(<span class="string">&#x27;Argh,broken:&#x27;</span> + err.message)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 虽说这代码逐渐就完全看不懂了</span></span><br></pre></td></tr></table></figure>
<p>哈哈（<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/async-best-example.html">查看示例</a>），鱼与熊掌兼得！加载所有内容的时间未变，但用户可以更早看到这一章。</p>
<p><img src="https://link/" alt="图略"></p>
<p>这个小例子中各章节加载差不多同时完成，逐章显示的策略在章节内容很多的时候优势会更加显著。</p>
<p>上面的代码如果 <a target="_blank" rel="noopener" href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce">用 Node.js 风格的回调或者事件机制实现</a>的话代码量大约要翻一倍，更重要的是可读性也不如此例。然而，Promise 的厉害不止于此，和其他 ES6 的新功能结合起来还能更高效……</p>
<h2 id="附赠章节：Promise-和-Generator"><a href="#附赠章节：Promise-和-Generator" class="headerlink" title="附赠章节：Promise 和 Generator"></a>附赠章节：Promise 和 Generator</h2><p>接下来的内容涉及到一大堆 ES6 的新特性，不过对于现在应用 Promise 来说并非必须，把它看作接下来第二部豪华续集的预告片来看就好了。</p>
<p>ES6 还给我们带来了 <a target="_blank" rel="noopener" href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">Generator</a>,允许函数在特定地方像 return 一样退出，但是稍后又能恢复到这个位置和状态上继续执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">addGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    i += <span class="keyword">yield</span> i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意函数名前的星号，这表示这是一个 Generator。关键字 yield 标记了暂停/继续的位置，使用方法像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = addGenerator()</span><br><span class="line">adder.next().value <span class="comment">// 0</span></span><br><span class="line">adder.next(<span class="number">5</span>).value <span class="comment">// 5</span></span><br><span class="line">adder.next(<span class="number">5</span>).value <span class="comment">// 10</span></span><br><span class="line">adder.next(<span class="number">5</span>).value <span class="comment">// 15</span></span><br><span class="line">adder.next(<span class="number">50</span>).value <span class="comment">// 65</span></span><br></pre></td></tr></table></figure>
<p>这对 Promise 有什么用呢？你可以用这种暂停/继续的机制写出来和同步代码看上去差不多(理解起来也一样简单)的代码。下面是一个辅助函数（helper function），我们在 <code>yeild</code> 位置等待 Promise 完成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">funciton <span class="function"><span class="title">spawn</span>(<span class="params">generatorFunc</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">continuer</span>(<span class="params">verb,arg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      result = generator[verb](arg);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.done)&#123;</span><br><span class="line">      <span class="keyword">return</span> result.value</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.cast(result.value).then(onFulfilled, onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> generator = generatorFunc()</span><br><span class="line">  <span class="keyword">var</span> onFulfilled = continuer.bind(continuer,<span class="string">&#x27;next&#x27;</span>)</span><br><span class="line">  <span class="keyword">var</span> onRejected = continuer.bind(continuer,<span class="string">&#x27;throw&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> onFulfilled()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 属实就完全看不懂了 -->

<p>这段代码<a target="_blank" rel="noopener" href="https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500">原样拷贝自 Q</a>，只是改成 JavaScript Promise 的 API。把我们前面的最终方案和 ES6 最新特性结合在一起之后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// &#x27;yield&#x27; effectively does an async wait</span></span><br><span class="line">    <span class="comment">// returning the result of the promise</span></span><br><span class="line">    <span class="keyword">let</span> story = <span class="keyword">yield</span> getJSON(<span class="string">&#x27;story.json&#x27;</span>)</span><br><span class="line">    addHtmlToPage(story.heading)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map our array of chapter urls to an array of chapter json promises.</span></span><br><span class="line">    <span class="comment">// This makes sure they all download parallel.</span></span><br><span class="line">    <span class="keyword">let</span> chapterPromises = story.chapterUrls.map(getJSON)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> chapterPromise <span class="keyword">of</span> chapterPromises) &#123;</span><br><span class="line">      <span class="comment">// Wait for each chapter to be ready,then add it to the page</span></span><br><span class="line">      <span class="keyword">let</span> chapter = <span class="keyword">yield</span> chapterPromise</span><br><span class="line">      <span class="comment">// 联系到 async await 有点明白了</span></span><br><span class="line">      addHtmlToPage(chapter.html)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addTextToPage(<span class="string">&#x27;ALL done&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// try/catch just works ,rejected promises are thrown here</span></span><br><span class="line">    addTextToPage(<span class="string">&#x27;Argh,broken:&#x27;</span> + err.message)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;.spinner&#x27;</span>).style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>功能完全一样，读起来要简单得多。这个例子目前可以在 Chrome Canary 中运行（<a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/es6/promises/async-generators-example.html">查看示例</a>）,不过你得先到 about:flags 中开启 <strong>Enable experimental JavaScript</strong>选项。</p>
<p>这里用到了一堆 ES6 的新语法：Promise、Generator、let、for-of。当我们把 <code>yield</code> 应用在一个 Promise 上，spawn 辅助函数会等待 Promise 完成，然后才返回最终的值。如果 Promise 给出否定结果，spawn 中的 yield 则会抛出一个异常，我们可以用 try/catch 捕捉到。这样写异步代码超级简单！</p>
<h2 id="Promise-API-参考"><a href="#Promise-API-参考" class="headerlink" title="Promise API 参考"></a>Promise API 参考</h2><p>除非额外注明，最新版的 Chrome（Canary）和 Firefox（nightly）均支持下列所有方法。<a target="_blank" rel="noopener" href="https://github.com/jakearchibald/ES6-Promises/blob/master/README.md">这个 Polyfill</a>则在所有浏览器内实现同样的接口。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Promise-cast-promise"><a href="#Promise-cast-promise" class="headerlink" title="Promise.cast(promise)"></a>Promise.cast(promise)</h4><p>返回一个 Promise（当且仅当 promise.constructor == Promise)<br>备注：目前仅有 Chrome 实现</p>
<h4 id="Promise-cast-obj"><a href="#Promise-cast-obj" class="headerlink" title="Promise.cast(obj)"></a>Promise.cast(obj)</h4><p>创建一个以 obj 为成功结果的 Promise。<br>备注：目前仅有 Chrome 实现</p>
<h4 id="Promise-resolve-thenable"><a href="#Promise-resolve-thenable" class="headerlink" title="Promise.resolve(thenable)"></a>Promise.resolve(thenable)</h4><p>从 thenable 对象创建一个新的 Promise。一个 thenable（类 Promise）对象是一个带有“then”方法的对象。如果你传入一个原生的 JavaScript Promise 对象，则会创建一个新的 Promise。此方法涵盖了 Promise.cast 的特性，但是不如 Promise.cast 更简单高效。</p>
<h4 id="Promise-resolve-obj"><a href="#Promise-resolve-obj" class="headerlink" title="Promise.resolve(obj)"></a>Promise.resolve(obj)</h4><p>创建一个以 obj 为确认结果的 Promise。这种情况下等同于 Promise.cast(obj)</p>
<h4 id="Promise-reject-obj"><a href="#Promise-reject-obj" class="headerlink" title="Promise.reject(obj)"></a>Promise.reject(obj)</h4><p>创建一个以 obj 为否定结果的 Promise。为了一致性和调试便利（如堆栈追踪），obj 应该是一个 Error 实例对象。</p>
<h4 id="Promise-all-obj"><a href="#Promise-all-obj" class="headerlink" title="Promise.all(obj)"></a>Promise.all(obj)</h4><p>创建一个 Promise，当且仅当传入数组中的所有 Promise 都确认之后才确认，如果遇到数组中的任何一个 Promise 以否定结束，则抛出否定结果。每个数组元素都会首先经过 Promise.cast,所以数组可以包含类Promise对象或者其他对象。确认结果是一个数组，包含传入数组中的每个 Promise 的确认结果（<strong>且保持顺序</strong>）；否定结果是传入数组中第一个遇到的否定结果。<br>备注：目前仅有 Chrome 实现</p>
<h4 id="Promise-race-array"><a href="#Promise-race-array" class="headerlink" title="Promise.race(array)"></a>Promise.race(array)</h4><p>创建一个 Promises，当数组中的任意对象确认时将其结果作为确认结束，或者当数组中任意对象否定时将其结果作为否定结束。</p>
<p>备注：我不大确定这个接口是否有用，我更倾向于一个 Promise.all的队里方法，仅当所有数组元素全部给出否定的时候才抛出否定结构。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9A%8F%E6%95%B2/" rel="tag"># 随敲</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/09/20/%E9%9A%8F%E6%95%B2-JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-2021-09-20-%E5%BC%95%E8%A8%80/" rel="prev" title="OOP | 引言">
      <i class="fa fa-chevron-left"></i> OOP | 引言
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/09/25/%E9%9A%8F%E6%95%B2-JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97-2021-09-25-%E5%8E%9F%E5%9E%8B/" rel="next" title="OOP | 原型">
      OOP | 原型 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%96%E4%BB%AC%E9%83%BD%E5%9C%A8%E6%BF%80%E5%8A%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">他们都在激动什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%B8%8D%E6%98%AF%E4%B8%87%E9%87%91%E6%B2%B9"><span class="nav-number">2.</span> <span class="nav-text">事件不是万金油</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD"><span class="nav-number">3.</span> <span class="nav-text">相关术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-%E6%9C%89%E4%BA%86-Promise"><span class="nav-number">4.</span> <span class="nav-text">JavaScript 有了 Promise</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%94%AF%E6%8C%81%E5%92%8C-Polyfill"><span class="nav-number">5.</span> <span class="nav-text">浏览器支持和 Polyfill</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%BA%93%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="nav-number">6.</span> <span class="nav-text">与其他库的兼容性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%8F%98%E5%BE%97%E6%9B%B4%E7%AE%80%E5%8D%95%E4%BA%86"><span class="nav-number">7.</span> <span class="nav-text">复杂的异步代码变得更简单了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86-Promise-%E7%94%A8%E4%BA%8E-XMLHttpRequest"><span class="nav-number">8.</span> <span class="nav-text">将 Promise 用于 XMLHttpRequest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">链式调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">9.1.</span> <span class="nav-text">值的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">9.2.</span> <span class="nav-text">队列的异步操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-%E5%BC%82%E5%B8%B8%E5%92%8C-Promise"><span class="nav-number">10.1.</span> <span class="nav-text">JavaScript 异常和 Promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">10.2.</span> <span class="nav-text">实践错误处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E4%B8%B2%E8%A1%8C%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E9%B1%BC%E4%B8%8E%E7%86%8A%E6%8E%8C%E5%85%BC%E5%BE%97"><span class="nav-number">11.</span> <span class="nav-text">并行和串行————鱼与熊掌兼得</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%BA%8F%E5%88%97"><span class="nav-number">11.1.</span> <span class="nav-text">创建序列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E8%B5%A0%E7%AB%A0%E8%8A%82%EF%BC%9APromise-%E5%92%8C-Generator"><span class="nav-number">12.</span> <span class="nav-text">附赠章节：Promise 和 Generator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-API-%E5%8F%82%E8%80%83"><span class="nav-number">13.</span> <span class="nav-text">Promise API 参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">13.1.</span> <span class="nav-text">静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-cast-promise"><span class="nav-number">13.1.1.</span> <span class="nav-text">Promise.cast(promise)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-cast-obj"><span class="nav-number">13.1.2.</span> <span class="nav-text">Promise.cast(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-resolve-thenable"><span class="nav-number">13.1.3.</span> <span class="nav-text">Promise.resolve(thenable)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-resolve-obj"><span class="nav-number">13.1.4.</span> <span class="nav-text">Promise.resolve(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-reject-obj"><span class="nav-number">13.1.5.</span> <span class="nav-text">Promise.reject(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-all-obj"><span class="nav-number">13.1.6.</span> <span class="nav-text">Promise.all(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-race-array"><span class="nav-number">13.1.7.</span> <span class="nav-text">Promise.race(array)</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Somebody</p>
  <div class="site-description" itemprop="description">My vegetable has exploded!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Somebody</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
