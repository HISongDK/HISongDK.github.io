---
title: Hooks FAQ
date: 2021-07-21 13:22:10
tags:
---

## Hooks FAQ

- [Hooks FAQ](#hooks-faq)
  - [采纳策略](#采纳策略)
    - [哪个版本的 React 包含了 Hook？](#哪个版本的-react-包含了-hook)
    - [我需要重写所有的 class 组件么？](#我需要重写所有的-class-组件么)
    - [有什么是 Hook 能做而 class 做不到的？](#有什么是-hook-能做而-class-做不到的)
    - [我的 React 知识还有多少是仍然有用的？](#我的-react-知识还有多少是仍然有用的)
    - [我应该使用 Hook，class，还是两者混用？](#我应该使用-hookclass还是两者混用)
    - [Hook 能否覆盖 class 的所有使用场景？](#hook-能否覆盖-class-的所有使用场景)
    - [Hook 会替代 render props 和高阶组件么？](#hook-会替代-render-props-和高阶组件么)
    - [Hook 对于 Redux connect() 和 React Router 等流行的 API 来说，意味着什么？](#hook-对于-redux-connect-和-react-router-等流行的-api-来说意味着什么)
    - [Hook 能和静态类型一起用么？](#hook-能和静态类型一起用么)
    - [如何测试使用了 Hook 的组件？](#如何测试使用了-hook-的组件)
    - [lint 规则具体强制了哪些内容？](#lint-规则具体强制了哪些内容)
  - [从 Class 迁移到 Hook](#从-class-迁移到-hook)
    - [生命周期要如何对应到 Hook ？](#生命周期要如何对应到-hook-)

_Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其它的 React 特性。_

此章节回答了关于 Hook 的常见问题。

- 采纳策略
  - 哪个版本的 React 包含了 Hook？
  - 我需要重写所有的 class 组件么？
  - 有什么是 Hook 能做而 class 做不到的？
  - 我的 React 知识还有多少是仍然有用的？
  - 我应该使用 Hook，class，还是两者混淆？
  - Hook 能否覆盖 class 的所有使用场景？
  - Hook 会代替 render props 和高阶组件么？
  - Hook 对于 Redux connect() 和 ReactRouter 等流行 API 来说，意味着什么？
  - Hook 能和静态类型一起用么？
  - 如何测试使用了 Hook 的组件？
  - lint 规则具体强制了哪些内容？
- 从 class 迁移到 Hook
  - 生命周期方法要如何对应到 Hook ？

### 采纳策略

#### 哪个版本的 React 包含了 Hook？

从 16.8.0 开始，React 在以下模块中包含了 ReactHook 的稳定实现：

- ReactDOM
- ReactNative
- React DOM Server
- React Test Server
- React Shallow Renderer

**请注意，要启用 Hook，所有 React 相关的 package 都必须升级到 16.8.0 或更高版本。**如果你忘记更新诸如 ReactDOM 之类的 package，Hook 将无法运行。

ReactNative 0.59 及以上版本支持 Hook。

#### 我需要重写所有的 class 组件么？

不。我们并没有计划从 React 中移除 class 我们也需要不断地发布产品，重写成本较高。我们推荐在新代码中尝试 Hook。

#### 有什么是 Hook 能做而 class 做不到的？

Hook 提供了强大而富有表现力的方式在组件之间复用功能。通过[【自定义 Hook 】](https://react.docschina.org/docs/hooks-custom.html)这一节可以了解能用它做些什么。这篇来自一位 React 核心团队的成员的文章则更加深入剖析了 Hook 解锁了哪些新的能力。

#### 我的 React 知识还有多少是仍然有用的？

Hook 是使用你已经知道的 React 特性的一种更直接的方式————比如 state，生命周期，context，以及 refs。他们并没有从根本上改变 React 的工作方式，你对组件，props，以及自顶向下的数据流的知识并没有改变。

Hook 确实有他们自己的学习曲线。如果这份文档中遗失了一些什么，提一个 issue，我们会尽可能地帮你。

#### 我应该使用 Hook，class，还是两者混用？

当你准备好了，我们鼓励你在写新组件地时候开始尝试 Hook。请确保你的团队中地每个人都愿意使用它们并且熟知这份文档中的内容。我们不推荐用 Hook 重写你已有的 class，除非你本来就打算重写它们。（例如：为了修复 bug ）。

你不能在 class 组件 _内部_ 使用 Hook ，但毫无疑问你可以在组件树里混合使用 class 组件和使用了 Hook 地函数组件。不论一个组件是 class 还是一个使用了 Hook 的函数，都只是这个组件的实现细节而已。长远来看，我们期望 Hook 能够成为人们编写 React 组建的主要方式。

#### Hook 能否覆盖 class 的所有使用场景？

我们给 Hook 设定的目标是尽早覆盖 class 的所有使用场景。目前暂时还没有对应不常用的 `getSnapshotBeforeUpdate`,`getDerivedStateFromError` 和 `componentDidCatch`生命周期的 Hook 等价写法，但我们计划尽早把它们加进来。

目前 Hook 还处于早期阶段，一些第三方的库可能还暂时无法兼容 Hook。

#### Hook 会替代 render props 和高阶组件么？

通常，render props 和高阶组件只渲染一个子节点。我们认为让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 `renderItem` 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。

#### Hook 对于 Redux connect() 和 React Router 等流行的 API 来说，意味着什么？

你可以继续使用之前的 API；他们仍会继续有效。

ReactRedux 从 v7.1.0 开始支持 Hook API 并暴露了 `useDispatch` 和 `useSelector` 等 hook。

ReactRouter 从 v5.1 开始支持 hook。

其他第三方库也将即将支持 hook 。

#### Hook 能和静态类型一起用么？

Hook 在设计阶段就考虑了静态类型的问题。因为它们是函数，所以他们比像高阶组件这样的模式更易于设定正确的类型。最新版的 Flow 和 TypeScript React 定义已经包含了对 React Hook 的支持。

重要的是，在你需要严格限制类型的时候，自定义 Hook 能够帮你限制 React 的 API。React 知识给你提供了基础功能，具体怎么用就是你自己的事了。

#### 如何测试使用了 Hook 的组件？

在 React 看来，一个使用了 Hook 的组件只不过是一个常规组件。如果你的测试方案不依赖于 React 的内部实现，测试带 Hook 的组件应该和你通常测试组件的方式没什么差别。

**`注意：`**[测试技巧](https://react.docschina.org/docs/testing-recipes.html)**`中包含了许多可以拷贝粘贴的示例。`**

举个例子，比如我们有这么个计数组件：

```js
function Example() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

我们会使用 ReactDOM 来测试它。为了确保它表现得和在浏览器中一样，我们会把代码渲染的部分包裹起来，并更新为 `ReactTestUtils.act()`调用：
<!-- 不得不说！测试示例代码的语法给我看懵了！再议 -->

```js
import React from 'react';
import ReactDOM from 'react-dom';
import { act } from 'react-dom/text-utils'
import Counter from './Counter';

let container;

beforeEach(()=>{
  container = document.createrElement('div')
  document.body.appendChild(container)
})

afterEach(()=>{
  document.body.removeChild(container);
  // body 元素 可以从 document 对象上直接获取
  container = null;
})

it('can render and update a counter',()=>{
  // 测试首次渲染和 effect

  act(()=>{
    ReactDOM.render(<Counter/>,container)
  })

  const button = container.querySelector('button')
  // querySelector 一直以为只是能在 document 上调用的，原来如簇和，是所有 html 元素的原型对象上的 方法么
  const label = container.querySelector('p')

  expect(label.textContent).toBe('You clicked 0 times')
  // textContent 文本内容属性
  expect(document.title).toBe('You clicked 0 times')

  act(()=>{
    button.dispatchEvent(new MouseEvent('click',{bubbles:true}))
    // 该元素触发鼠标点击事件 支持冒泡
    // dispatchEvent 方法和 MouseEvent 对象，也都是头一次见
  })

  expect(label.textContent).toBe('You clicked 1 times')
  expect(document.title).toBe('You clicked 1 times')
})
```

对 act() 的调用也会清空他们内部的 effect。

如果你需要测试一个自定义 Hook ，你可以在你的测试代码中创建一个组件并在其中使用你的 Hook 。然后你就可以测试你刚写的组建了。

为了减少不必要的模板项目，我们推荐使用 React Testing Library ，该项目旨在鼓励你按照终端用户使用组件的方式来编写测试。

欲了解更多，请参阅[阅读技巧](https://react.docschina.org/docs/testing-recipes.html)一节。

#### lint 规则具体强制了哪些内容？

我们提供了一个 ESLint 插件来强制Hook规范以避免Bug。它假设任何以【use】开头并紧跟一个大写字母的函数就是一个 Hook 。我们知道这种启发方式并不完美，甚至存在一些伪真理，但如果没有一个全生态范围的约定就没法让 Hook 很好的工作————而名字太长会让人要么不愿意采用 Hook ，要么不愿意遵守约定。

规范尤其强制了一下内容：

- 对 Hook 的调用要么在一个 `大驼峰法` 命名的函数（视作一个组件）内部，要么在另一个 `useSomething` 函数（视作一个自定义 Hook ）中。
- Hook 在每次渲染时按照相同的顺序调用。

还有一些其他的启发方式，但随着我们不断地调优以在发现 Bug 和避免伪真理之前取得平衡，这些方式随时会改变。

### 从 Class 迁移到 Hook

#### 生命周期要如何对应到 Hook ？

- `constructor`: 函数组件不需要构造函数。你可以通过 useState 来初始化 state。如果计算的代价比较昂贵，你可以传一个函数给 useState。
- `getDerivedStateFromProps`: 改为 在渲染时 安排一次更新。
