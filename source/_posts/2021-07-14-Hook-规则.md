---
title: Hook 规则
date: 2021-07-14 23:11:10
tags:
---

## Hook 规则

*Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。*

Hook 本质就是 JavaScript 函数，但是在使用它时需要遵守两条规则。我们提供了一个 linter 插件来强制执行这些规则：

### 只在最顶层使用 Hook

**不要在循环，条件或嵌套函数中调用 Hook，**确保是在你的 React 函数的最顶层以及任何 return 之前调用它们。遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 Hook 状态的正确。（若果你此感到好奇，我们在下面会更深入的解释。）

### 只在 React 函数中调用 Hook

**不要在普通的 javascript 函数中调用 Hook。**你可以：

-[x] 在 React 的函数组件中调用 Hook
-[x] 在自定义 Hook 中调用其他 Hook(我们将在下一页中学习这个)

遵循此规则，确保组件的状态逻辑在代码中清晰可见。

### ESLint 插件

我们发布了一个名为 eslint-plugin-react-hooks 的 ESLint 插件来强制执行这两条规则。如果你想尝试一下，可以将此插件添加到你的项目中：

我们打算后续版本默认添加此插件到 Create React App 及其他类似的工具包中。

```js
npm install eslint-plugin-react-hooks --save-dev
```

```js
// 你的 ESLint 配置
{
  "plugins": [
    // ...
    "react-hooks"
  ],
  "rules": {
    // ...
    "react-hooks/rules-of-hooks": "error", // 检查 Hook 的规则
    "react-hooks/exhaustive-deps": "warn" // 检查 effect 的依赖
  }
}
```

**现在你可以跳转到下一张学习如何编写你自己的 Hook 。**在本章节中，我们将继续解释这些背后的原因。

### 说明

正如我们之前学到的，我们可以在单个组件中使用多个 State Hook 或 Effect Hook

```js
function Form(){
 // 1. Use the name state variable
 const [name,setName] = useState('Mary')
 // 2. Use an effect for persisting the form
 useEffect(function persistForm(){
  localhost.setItem('formData',name)
 })
 // 3. Use the sruname variable
 const [surname,setSurname] = useState('Poppins') 
 // 4. Use an effect for updating the title
 useEffect(function udateTitle(){
  document.title = name + " " + surname
 })
 // ...
}
```

那么 React 怎么知道哪个 state 对应哪个 useState ？ 答案是 React 靠的是 Hook 调用的顺序。因为我们的示例中，Hook 的调用顺序在每次渲染中都是相同的，所以它能正常工作:


