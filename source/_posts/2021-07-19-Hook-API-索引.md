---
title: Hook API 索引
date: 2021-07-19 13:05:41
tags:
---

## Hook API 索引

- [Hook API 索引](#hook-api-索引)
  - [基础 Hook](#基础-hook)
    - [useState](#usestate)
      - [函数式更新](#函数式更新)
      - [惰性初始 state](#惰性初始-state)
      - [跳过 state 更新](#跳过-state-更新)
    - [useEffect](#useeffect)
      - [清除 effect](#清除-effect)
      - [effect 的执行时机](#effect-的执行时机)
      - [effect 的条件执行](#effect-的条件执行)

_Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。_

本页面主要描述 React 中内置的 Hook API。

如果你刚开始接触 Hook，那么可能需要先查阅 Hook 概览。你也可以在 `Hooks FAQ` 章节中获取有用的信息。

- 基础 Hook
  - useState
  - useEffect
  - useContext
- 额外的 Hook
  - useReducer
  - useCallback
  - useMemo
  - useRef
  - useImperativeHandle
  - useLayoutEffect
  - useDebugValue

---

### 基础 Hook

#### useState

```js
const [state, setState] = useState(initialState);
```

返回一个 state，以及更新 state 的函数。

在初始渲染期间，返回的状态（state）与传入的第一个参数（initialState）值相同。

`setState`函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。

```js
setState(newState);
```

在后续的重新渲染中，`useState` 返回的第一个值始终是更新后最新的 state。

**`注意： React 会确保 setState 函数的标识是稳定的，并且不会再组件重新渲染时发生变化。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 setState。`**

##### 函数式更新

如果新的 state 需要通过使用先前的计算得出，那么可以将函数传递给 `setState`。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 `setState` 的两种用法：

```js
function Counter({ initialCount }) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount((prevCount) => prevCount - 1)}>-</button>
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>+</button>
    </>
  );
}
```

" + " 和 " - " 按钮采用函数式形式，因为被更新地 state 需要基于之前的 state 。但是"重置"按钮则采用普通形式，因为它总是把 count 设置会初始值。

如果你地更新函数返回值与当前 state 完全相同，则随后地重新渲染会被完全跳过。

```js
注意： 与 class 组件中的 setState 方法不同， useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达

const [state,setState] = useState({})
setState(prevState=>{
  // 也可以使用 Object.assign
  return {...prevState,...updateValues}
})

useReducer 是另一种可选方案，它更适用于管理包含多个子值的 state 对象。

```

##### 惰性初始 state

`initialState` 参数只在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂的计算获得，则可以传入一个函数，在函数中计算并返回初始的 state ，此函数只在初始渲染时被调用：

```js
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

##### 跳过 state 更新

调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过自组建的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state 。）

需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的 “深层” 节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。

#### useEffect

```js
useEffect(didUpdate);
```

该 Hook 接受一个包含命令式、且可能有副作用代码的函数。

在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。

使用 `useEffect` 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的**纯函数式世界通往命令式世界的逃生通道。**

**默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它在只有某些值改变的时候才执行。**

##### 清除 effect

通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。 要实现这一点，`useEffect` 函数需要返回一个清除函数。以下就是一个创建订阅的例子：

```js
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // 清除订阅
    subscription.unsubscribe();
  };
});
```

为防止内存泄漏，清楚函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则 **在执行下一个 effect 之前，上一个 effect 就已经被清除了。**在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都出发 effect 的执行，请参阅下一小节。

##### effect 的执行时机

与 `componentDidMount`、`componentDidUpdate` 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的的副作用场景，不如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。

然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 `useLayoutEffect` Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用的时机不同。

虽然 `useEffect` 会在浏览器会滞后延迟执行，但会保证在任何新的渲染前执行。再开始新的更新前，react 总会先清除上一轮渲染的 effect。

##### effect 的条件执行

默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。

然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变的时候重新创建。

要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：

```js
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    subscription.unsubscribe();
  };
}, [props.source]);
```

此时，只有当 props.source 改变后才会重新创建订阅。

```china
注意：
如果你要使用此优化方式，请确保数组中包含了 所有外部作用域中会发生变化且在 effect 中使用到的变量， 否则你的代码会引用到先前渲染中的旧变量。请参阅文档，了解更多关于如何处理函数以及数组频繁变化时的措施的内容。

如果想只执行一次的 effect (仅在组件挂载和卸载时执行)，可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以他永远都不需要重复执行。这并不属于特殊情况————它依然遵循数组的工作方式。


```
