---
title: Hook API 索引
date: 2021-07-19 13:05:41
tags:
---

## Hook API 索引

- [Hook API 索引](#hook-api-索引)
  - [基础 Hook](#基础-hook)
    - [useState](#usestate)
      - [函数式更新](#函数式更新)
      - [惰性初始 state](#惰性初始-state)
      - [跳过 state 更新](#跳过-state-更新)
    - [useEffect](#useeffect)
      - [清除 effect](#清除-effect)
      - [effect 的执行时机](#effect-的执行时机)
      - [effect 的条件执行](#effect-的条件执行)
  - [useContext](#usecontext)
    - [把如下代码与 Context.Provider 放在一起](#把如下代码与-contextprovider-放在一起)
- [额外的 Hook](#额外的-hook)
  - [useReducer](#usereducer)
  - [useMemo](#usememo)
  - [useRef](#useref)

_Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。_

本页面主要描述 React 中内置的 Hook API。

如果你刚开始接触 Hook，那么可能需要先查阅 Hook 概览。你也可以在 `Hooks FAQ` 章节中获取有用的信息。

- 基础 Hook
  - useState
  - useEffect
  - useContext
- 额外的 Hook
  - useReducer
  - useCallback
  - useMemo
  - useRef
  - useImperativeHandle
  - useLayoutEffect
  - useDebugValue

---

### 基础 Hook

#### useState

```js
const [state, setState] = useState(initialState);
```

返回一个 state，以及更新 state 的函数。

在初始渲染期间，返回的状态（state）与传入的第一个参数（initialState）值相同。

`setState`函数用于更新 state。它接收一个新的 state 值并将组件的一次重新渲染加入队列。

```js
setState(newState);
```

在后续的重新渲染中，`useState` 返回的第一个值始终是更新后最新的 state。

**`注意： React 会确保 setState 函数的标识是稳定的，并且不会再组件重新渲染时发生变化。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 setState。`**

##### 函数式更新

如果新的 state 需要通过使用先前的计算得出，那么可以将函数传递给 `setState`。该函数将接收先前的 state，并返回一个更新后的值。下面的计数器组件示例展示了 `setState` 的两种用法：

```js
function Counter({ initialCount }) {
  const [count, setCount] = useState(initialCount);
  return (
    <>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount((prevCount) => prevCount - 1)}>-</button>
      <button onClick={() => setCount((prevCount) => prevCount + 1)}>+</button>
    </>
  );
}
```

" + " 和 " - " 按钮采用函数式形式，因为被更新地 state 需要基于之前的 state 。但是"重置"按钮则采用普通形式，因为它总是把 count 设置会初始值。

如果你地更新函数返回值与当前 state 完全相同，则随后地重新渲染会被完全跳过。

```js
注意： 与 class 组件中的 setState 方法不同， useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达

const [state,setState] = useState({})
setState(prevState=>{
  // 也可以使用 Object.assign
  return {...prevState,...updateValues}
})

useReducer 是另一种可选方案，它更适用于管理包含多个子值的 state 对象。

```

##### 惰性初始 state

`initialState` 参数只在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂的计算获得，则可以传入一个函数，在函数中计算并返回初始的 state ，此函数只在初始渲染时被调用：

```js
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

##### 跳过 state 更新

调用 State Hook 的更新函数并传入当前的 state 时，React 将跳过自组建的渲染及 effect 的执行。（React 使用 Object.is 比较算法 来比较 state 。）

需要注意的是，React 可能仍需要在跳过渲染前渲染该组件。不过由于 React 不会对组件树的 “深层” 节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 `useMemo` 来进行优化。

#### useEffect

```js
useEffect(didUpdate);
```

该 Hook 接受一个包含命令式、且可能有副作用代码的函数。

在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。

使用 `useEffect` 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的**纯函数式世界通往命令式世界的逃生通道。**

**默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它在只有某些值改变的时候才执行。**

##### 清除 effect

通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。 要实现这一点，`useEffect` 函数需要返回一个清除函数。以下就是一个创建订阅的例子：

```js
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // 清除订阅
    subscription.unsubscribe();
  };
});
```

为防止内存泄漏，清楚函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则 **在执行下一个 effect 之前，上一个 effect 就已经被清除了。**在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都出发 effect 的执行，请参阅下一小节。

##### effect 的执行时机

与 `componentDidMount`、`componentDidUpdate` 不同的是，传给 useEffect 的函数会在浏览器完成布局与绘制之后，在一个延迟事件中被调用。这使得它适用于许多常见的的副作用场景，不如设置订阅和事件处理等情况，因为绝大多数操作不应阻塞浏览器对屏幕的更新。

然而，并非所有 effect 都可以被延迟执行。例如，一个对用户可见的 DOM 变更就必须在浏览器执行下一次绘制前被同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 `useLayoutEffect` Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用的时机不同。

虽然 `useEffect` 会在浏览器会滞后延迟执行，但会保证在任何新的渲染前执行。再开始新的更新前，react 总会先清除上一轮渲染的 effect。

##### effect 的条件执行

默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。

然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变的时候重新创建。

要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：

```js
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    subscription.unsubscribe();
  };
}, [props.source]);
```

此时，只有当 props.source 改变后才会重新创建订阅。

```chinese
注意：
如果你要使用此优化方式，请确保数组中包含了 所有外部作用域中会发生变化且在 effect 中使用到的变量， 否则你的代码会引用到先前渲染中的旧变量。请参阅文档，了解更多关于如何处理函数以及数组频繁变化时的措施的内容。

如果想只执行一次的 effect (仅在组件挂载和卸载时执行)，可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以他永远都不需要重复执行。这并不属于特殊情况————它依然遵循数组的工作方式。



如果你传入了一个空数组（ [] ),effect 内部的 props 和 state 就会一直持有其初始值。尽管传入 [] 作为第二个参数有点类似于 componentDidMount 和 componentWillUnmount 的思维模式，但我们有更好的方法来避免与频繁的重复调用 effect 。除此之外，请记得 React 会等待浏览器完成画面渲染之后才会延迟调用 useEffect ，因此会使得处理额外操作很方便。

我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。
```

依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。

### useContext

```js
const value = useContext(MyContext);
```

接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 `<MyContext.Provideer>` 的 value prop 决定。

当组件上层最近的`<MyContext.Provideer>` 更新时，该 Hook 会触发重渲染，并使用最新传递给 `MyContext` provider 的 context value 值。即使祖先使用 `React.memo` 或 `shouldConponentUpdate`，也会在组件本身使用 `useContext` 时重新渲染。

别忘记 `useContext` 的参数必须是 _context_ 对象本身:

- 正确：`useContext(MyContet）`
- 错误：`useContext(MyContet.Consumer）`
- 错误：`useContext(MyContet.Provider）`

调用了 `useContext`的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销太大，你可以通过使用 `memoization` 来优化。

**`提示： 如果你在接触 Hook 前已经对 contextAPI 比较熟悉，那应该可以理解，useContext(MyContext) 相当于 class 组件中的 static contextType = MyContext 或者 <MyContext.Consumer>。 useContext(MyContext) 只是让你能够读取 context 的值已经订阅 context 的变化。你仍然需要在上层组件树中使用<MyContext.Provide> 来为下层组件提供 context 。`**

#### 把如下代码与 Context.Provider 放在一起

```js
const themes = {
  light:{
    foreground:'#000',
    background:'#eee'
  },
  dark:{
    foreground:'#fff',
    background:'#222'
  }
}

const ThemeContext = React.createContext(themes.light);

function App(){
  return (
    <ThemeContext.Provider value={themes.dark}>
      <Toolbar>
    </ThemeContext.Provider>
  )
}

function Toobar(props)  {
  return (
    <div>
      <ThemedButton>
    </div>
  )
}

function ThemedButton(){
  const theme = useContext(ThemeContext)

  return(
    <button style={{background:theme.backgroudn,color:theme.foreground}}>
      I am styled by theme context!
    </button>
  )
}
```

对先前 [Context 高级指引](https://react.docschina.org/docs/context.html)中的示例使用 hook 进行了修改，你可以在链接中找到有关如何 Context 的更对信息。

## 额外的 Hook

已下介绍的 Hook ，有些上上一节中基础 Hook 的变体，有些则是仅在特殊情况下会用到。不用特意预先学习它们。<!--听你的-->

### useReducer

```js
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

`useState` 的代替方案。它接收一个形如（state，action）=> newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）

在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数。

以下是用 reducer 重写 useState 一节的计数器示例：

### useMemo

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

返回一个 memoized 值。

把“创建”函数和依赖项作为参数传入 useMemo，它仅会在某个依赖项发生改变时才重新计算 memoized 的值。这种优化有助于避免在每次渲染时都进行高开销的计算。

记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。

如果没有提供依赖项数组， useMemo 在每次渲染时都会重新计算新的值。

**你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。**将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码————之后再你的代码中添加 useMemo，以达到性能优化的目的。

**`注意：依赖项数组不会作为参数传给“创建”函数。虽然从概念上来说它表现为：所有“创建”函数中引用的值应该出现在依赖性数组中。未来编译器会更加智能，届时自动创建数组将成为可能。 我们推荐启用 elsint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会再添加错误依赖项时发出警告并给出修复建议。`**

### useRef

```js
const refContainer = useRef(initalValue);
```

useRef 返回一个可变的 ref 对象，其 `.current` 属性被初始化为传入的参数（initalValue）。返回的 ref 对象再组件的整个生命周期内保存不变。

一个常见的用例便是命令式地访问子组件：

```js
function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    // current 指向已挂载到 DOM 上地文本输入元素
    inputEl.current.focus();
  };
  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </>
  );
}
```

本质上， useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。

你应该熟悉 ref 这一种访问 DOM 的主要形式。如果你将 ref 对象以 `<div ref={myRef}/>` 形式传入组件，则无论改节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。

然而，useRef() 比 ref 属性更有用。它可以方便的保存任何可变值，其类似于在 class 中使用实例字段的方式。

这是因为它创建的是一个普通的 JavaScript 对象。而 useRef 和自建一个 {current:...} 对象的唯一区别是， useRef 会在每次渲染时返回同一个 ref 对象。

请记住，当 ref 对象内容发生变化， useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或者解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。
