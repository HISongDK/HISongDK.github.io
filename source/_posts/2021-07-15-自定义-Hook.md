---
title: 自定义 Hook
date: 2021-07-15 23:05:23
tags:
---

## 自定义 Hook

- [自定义 Hook](#自定义-hook)
  - [提取自定义 Hook](#提取自定义-hook)
  - [使用自定义 Hook](#使用自定义-hook)
  - [提示：在多个 Hook 之间传递信息](#提示在多个-hook-之间传递信息)

_Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。_

通过自定义 Hook，可以将组件逻辑提取到可重用的函数中。

在我们学习使用 Effect Hook 时，我们已经见过这个聊天程序中的组件，该组件用于显示好友的在线状态：

```js
import React, { useState, useEffect } from "react";

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(stateus.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return "loading ...";
  }
  return isOnline ? "online" : "offline";
}
```

现在我们假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为绿色。我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中，但这并不是理想的解决方案：

```js
import React, { useState, useEffect } from "react";

function FriendListItem(props) {
  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  return (
    <li style={{ color: isOnline ? "green" : "black" }}>{props.friend.name}</li>
  );
}
```

相反，我们希望在 FriendStatus 和 FriendListItem 之间共享逻辑。目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑：`render props`和`高阶组件`,现在让我们来看看 Hook 是如何让你不增加组件的情况下解决相同的问题。

### 提取自定义 Hook

当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 Hook 都是函数，所以也同样适用这种方式。

**自定义 Hook 是一个函数，其名称以`use`开头，函数内部可以调用其他的 Hook。**例如，下面`useFriendStatus`是我们第一个自定义的 Hook：

```js
import { useState, useEffect } from "react";

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
```

此处并未包含任何新的内容————逻辑从上述组件中拷贝来的。与组件中一致，请确保只在自定义 Hook 的顶层无条件地调运其他 Hook。

与 React 组件不同的是，自定义 Hook 不需要具有特殊的标识。我们可以决定它的参数是什么，以及它应该返回什么（如果需要的话）。换句话说，它就像一个正常地函数。但是它的名字应该始终以`use`开头，这样可以一眼看出其符合 Hook 的规则。

此处`useFriendStatus`的 Hook 目的是订阅某个好友的在线状态。**这就是我们需要将`friendID`作为参数，并返回这位好友的在线状态的原因。**

```js
function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  // ...

  return isOnline;
}
```

现在让我们看看应该如何使用自定义 Hook 。

---

### 使用自定义 Hook

我们一开始的目标是 FriendStatus 和 FriendListItem 组件中去除重复的逻辑，即这两个组件都想知道好友是否在线。

现在我们已经把这个逻辑提取到 useFriendStatus 的自定义 Hook 中，然后就可以使用它了：

```js
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return "Loading...";
  }
  return isOnline ? "Online" : "Offline";
}

//-----------
function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    <li style={{ color: isOnline ? "green" : "black" }}>{props.friend.name}</li>
  );
}
```

**这段代码等价于原来的示例代码吗？**等价，它的工作方式完全一样。如果你仔细观察，你会发现我们没有对其行为做任何改变，我们只是将两个函数之间一些共同的代码提取到单独的函数中。**自定义 Hook 是一种遵循 Hook 设计的约定，而不是 React 的特性。**

**自定义 Hook 必须以 “use” 开头么？**必须如此，这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。

**在两个组件中使用相同的 Hook 会共享 state 吗？**不会。自定义 Hook 是一种重用 _状态逻辑_ 的机制（例如设置为订阅并存储当前值），所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。

**自定义 Hook 如何获取独立的 state？**每次调用 Hook，它都会获取独立的 state。由于我们直接调用了 useFriendStatus，从 React 的角度来看 useState 和 useEffect。正如我们在之前章节了解到的一样，我们可以在一个组件中多次调用 useState 和 useEffect ，它们是完全独立的。

### 提示：在多个 Hook 之间传递信息

由于 Hook 本身就是函数，因此我们可以在他们之间传递信息。

我们将使用聊天程序中的另一个组件来说明这一点。这是一个聊天消息接收者的选择器，它会显示当前选定的好友是否在线：

```js
const friendList = [
  { id: 1, name: "Phoebe" },
  { id: 2, name: "Rachel" },
  { id: 3, name: "Ross" },
];

function ChatRecipientPicker(){
	
}
```
